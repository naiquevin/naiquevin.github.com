<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>/home/vineet - python</title><link href="http://naiquevin.github.io/" rel="alternate"></link><link href="http://naiquevin.github.io/feeds/python.atom.xml" rel="self"></link><id>http://naiquevin.github.io/</id><updated>2014-03-19T00:00:00+05:30</updated><entry><title>Toolbox: histit.py</title><link href="http://naiquevin.github.io/toolbox-histitpy.html" rel="alternate"></link><published>2014-03-19T00:00:00+05:30</published><updated>2014-03-19T00:00:00+05:30</updated><author><name>Vineet Naik</name></author><id>tag:naiquevin.github.io,2014-03-19:/toolbox-histitpy.html</id><summary type="html">&lt;p&gt;A command line tool to quickly plot histograms based on matplotlib&lt;/p&gt;</summary><content type="html">&lt;p&gt;(This is the first post of the series I plan to write on some tools I
have built over the last couple of years to help me in my day-to-day
tasks. I usually put all such tools in the repo
&lt;a href="https://github.com/naiquevin/toolbox"&gt;toolbox&lt;/a&gt; until they turn out
sufficiently useful to be worth separating into their own projects).&lt;/p&gt;
&lt;p&gt;The first post is about a command line tool named &lt;code&gt;histit.py&lt;/code&gt; that I
use for quickly plotting histograms &lt;a id="footnote-1-ref"
href="#footnote-1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; by reading data from text
files. It's basically a simple wrapper over
&lt;a href="http://matplotlib.org/"&gt;matplotlib&lt;/a&gt;, a library that's quite popular
for plotting all kinds of stuff in Python.&lt;/p&gt;
&lt;p&gt;You can download the script from
&lt;a href="https://raw.github.com/naiquevin/toolbox/master/histit.py"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    $ wget https://raw.github.com/naiquevin/toolbox/master/histit.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;hisit.py&lt;/code&gt; depends upon &lt;a href="http://www.numpy.org/"&gt;numpy&lt;/a&gt; and matplotlib
so first make sure they are installed &lt;a id="footnote-2-ref"
href="#footnote-2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We need some data for the demo, so let's first dump values from a
random normal distribution into a text file. The &lt;code&gt;numpy.random.normal&lt;/code&gt;
function can be used for this.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
    &lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;data.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
       &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we can use &lt;code&gt;histit.py&lt;/code&gt; to plot the histogram as follows:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    $ python histit.py &lt;span class="s2"&gt;&amp;quot;Test histogram&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Test values&amp;quot;&lt;/span&gt; -d data.txt -a show -t float -b &lt;span class="m"&gt;100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If all goes well, a window &lt;a id="footnote-3-ref"
href="#footnote-3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; will popout with the histogram as
shown below. Although the values in your case would be different, a
peculiar "bell curve" should be noticeable.&lt;/p&gt;
&lt;p&gt;&lt;img alt="histogram demo" src="theme/images/histit-demo.png"&gt;&lt;/p&gt;
&lt;p&gt;In the command we just run,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"Test histogram" is the title of the plot,&lt;/li&gt;
&lt;li&gt;"Test values" is the label on the X-axis.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; option is for specifying the path to the data file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; option is for action (either of &lt;code&gt;show&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;show&lt;/code&gt; being
  the default)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; option is for specifying the type of input expected, here
  &lt;code&gt;float&lt;/code&gt; but the default is &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b&lt;/code&gt; option for specifying the no. of bins&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instead of loading data from a file, the script can also accept data
on the standard input stream in which case, the &lt;code&gt;-d&lt;/code&gt; option must be
skipped.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    $ cat data.txt &lt;span class="p"&gt;|&lt;/span&gt; python histit.py &lt;span class="s2"&gt;&amp;quot;Test histogram&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Test values&amp;quot;&lt;/span&gt; -a show -t float -b &lt;span class="m"&gt;100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I have been using this on a regular basis for some time but I am not
entirely convinced if it's worth publishing as a package on
PyPI. Anyway, at least it's got some documentation now :-)&lt;/p&gt;
&lt;h4&gt;Footnotes&lt;/h4&gt;
&lt;p&gt;&lt;b id="footnote-1"&gt;1.&lt;/b&gt; A histogram is a graphical representation of
frequency distribution. In simpler words, a graph of all unique values
in the data plotted against how many times each one appears. When
working with sufficient quantity of data, a histogram turns out to be
a pretty handy tool to guage the shape of the data at a
glance. See also: &lt;a href="http://en.wikipedia.org/wiki/Histogram"&gt;wikipedia&lt;/a&gt; &lt;a
href="#footnote-1-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b id="footnote-2"&gt;2.&lt;/b&gt; Actually it doesn't depend on numpy directly
but before installing matplotlib make sure numpy is installed in order
to avoid frustation. &lt;a href="#footnote-2-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b id="footnote-3"&gt;3.&lt;/b&gt; GTK window in my case as I am using the GTKAgg backend for
matplotlib. Please consult the docs to configure your preferred
backend. &lt;a href="#footnote-3-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;</content><category term="python"></category><category term="toolbox"></category><category term="histogram"></category></entry><entry><title>A look at some of Python's useful itertools</title><link href="http://naiquevin.github.io/a-look-at-some-of-pythons-useful-itertools.html" rel="alternate"></link><published>2013-05-23T00:00:00+05:30</published><updated>2013-05-23T00:00:00+05:30</updated><author><name>Vineet Naik</name></author><id>tag:naiquevin.github.io,2013-05-23:/a-look-at-some-of-pythons-useful-itertools.html</id><summary type="html">&lt;p&gt;.. with examples and use cases&lt;/p&gt;</summary><content type="html">&lt;p&gt;Couple of months back I enrolled for the
&lt;a href="https://www.coursera.org/course/progfun"&gt;Functional Programming Principles in Scala&lt;/a&gt;
course taught by Martin Odersky on Coursera. While solving one of the
early assignments, I remember searching for "Scala equivalent to
Python's range". By the end of the course, I was searching for python
equivalents for some of the methods and operations on scala
collections. There is no doubt that learning new and different
languages help you as a programmer in more than one way. Ok, I am
digressing, but what that search led me to was the insanely useful
&lt;a href="http://docs.python.org/2/library/itertools.html"&gt;itertools&lt;/a&gt; module
and it left me wondering - why didn't I take a &lt;em&gt;real&lt;/em&gt; look at it
earlier!&lt;/p&gt;
&lt;p&gt;In this article I am going to show some of the must-know itertools
that will make your everyday code more memory efficient, elegant and
concise. Instead of focusing on one function/class from the module at
a time, it would be helpful to see some real world (and not so real
world) use cases and examples of itertools.&lt;/p&gt;
&lt;p&gt;But before that, I should mention that I have tried the examples on
Python 2.7.3 and would recommend you use 2.7.x to follow along,
although they should &lt;em&gt;mostly&lt;/em&gt; work on Python 3.x too.&lt;/p&gt;
&lt;h3&gt;Taking "lazy" to the next level&lt;/h3&gt;
&lt;p&gt;In an
&lt;a href="http://naiquevin.github.io/python-generators-and-being-lazy.html"&gt;earlier blog post&lt;/a&gt;,
I had covered generators and how lazy evaluation can be used to write
memory efficient code. Itertools let you do more with the lazily
evaluated objects.&lt;/p&gt;
&lt;p&gt;You may already know that the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; BIFs can accept
not just a list but any iterator in general, which means we can also
pass them a generator. But doing so doesn't give us truly lazy
behaviour. Let's see an example to understand this.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_even&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;is_even called for &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;even&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_even&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;&lt;strong&gt;Edit&lt;/strong&gt;: Thanks to many comments, I replaced the redundant generator
expression &lt;code&gt;(i for i in xrange(20)&lt;/code&gt; with just &lt;code&gt;xrange&lt;/code&gt; in all
examples.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The above code defines a function &lt;code&gt;is_even&lt;/code&gt; to check if an integer
is even. In &lt;code&gt;even&lt;/code&gt;, we pass &lt;code&gt;is_even&lt;/code&gt; as a predicate to &lt;code&gt;filter&lt;/code&gt;
thus returning all even integers between 0 to 20. To get first four of
such integers, we can use the slice operator.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; even()[:4]&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 0&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 1&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 2&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 3&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 4&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 5&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 6&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 7&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 8&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 9&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 10&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 11&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 12&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 13&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 14&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 15&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 16&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 17&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 18&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 19&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; [0, 2, 4, 6]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While the result that we obtained is correct, our code is doing a lot
of unnecessary work. We can see this from the statements that are
getting printed every time &lt;code&gt;is_even&lt;/code&gt; is called (20
times). Wait.. but we just need first 4 items right, why is it even
getting called that many times?  The problem is that although we
started with a generator, &lt;code&gt;filter&lt;/code&gt; needs to run each item through
the predicate and so the generator ends up getting consumed. Finally,
we get a list from which we slice out the first 4 items.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; type(even())&lt;/span&gt;
&lt;span class="go"&gt;    &amp;lt;type &amp;#39;list&amp;#39;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;How can we do better? The idea is, we need a way to delay the
application of filter on the generator. &lt;code&gt;itertools.ifilter&lt;/code&gt; does
exactly that by returning a lazy object instead of a list. Items will
be filtered whenever some other function or a for loop consumes
them. Lets define another function &lt;code&gt;lazy_even&lt;/code&gt;,&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;lazy_even&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;itertools&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ifilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_even&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; nums = lazy_even()&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; type(nums)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;lt;type &amp;#39;itertools.ifilter&amp;#39;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ok, this gives us a lazy object. But the problem now is, we still need
a way to slice out the first 4 items without converting the entire
thing to a list. Itertools provides &lt;code&gt;islice&lt;/code&gt; for this which takes
the iterator, a start index and a stop index.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; first_four = itertools.islice(nums, 0, 4)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; type(first_four)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;lt;type &amp;#39;itertools.islice&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;    for i in first_four:&lt;/span&gt;
&lt;span class="go"&gt;    ...     print i&lt;/span&gt;
&lt;span class="go"&gt;    ... &lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 0&lt;/span&gt;
&lt;span class="go"&gt;    0&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 1&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 2&lt;/span&gt;
&lt;span class="go"&gt;    2&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 3&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 4&lt;/span&gt;
&lt;span class="go"&gt;    4&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 5&lt;/span&gt;
&lt;span class="go"&gt;    is_even called for 6&lt;/span&gt;
&lt;span class="go"&gt;    6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, now &lt;code&gt;is_even&lt;/code&gt; is called only while it's required.&lt;/p&gt;
&lt;h3&gt;Counting infinitely&lt;/h3&gt;
&lt;p&gt;Let's take another example. This time we need to find out 3 smallest
numbers that are greater than 1000 and powers of 2. In the eariler
blog post on generators, there was an example of counting infinitely
using the &lt;code&gt;yield&lt;/code&gt; keyword. Here we need to do something similar to
count integers and test whether or not each one is a power of 2. The
catch is that since we need to return 3 such numbers, we don't know
when to stop counting. Ok, probably in this case it's easy to
pre-calculate or guess, but what if the predicate function is a bit
more complex for eg. a check for primality? With itertools, we can use
the same technique as in the previous example. As a bonus, the module
comes with a &lt;code&gt;count&lt;/code&gt; function so we don't need to write our own.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; import math&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; from itertools import count, islice, ifilter&lt;/span&gt;

&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; def is_pow_two(x):&lt;/span&gt;
&lt;span class="go"&gt;    ...     ln = math.log(x, 2)&lt;/span&gt;
&lt;span class="go"&gt;    ...     return math.floor(ln) == ln&lt;/span&gt;

&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; list(islice(ifilter(is_pow_two, count(1000)), 0, 3))&lt;/span&gt;
&lt;span class="go"&gt;    [1024, 2048, 4096]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;is_pow_two&lt;/code&gt; will be called no more than 4096 times = win!&lt;/p&gt;
&lt;h3&gt;Grouping things in style&lt;/h3&gt;
&lt;p&gt;If you often use Python to write scripts for extracting data,
eg. scraping web pages or parsing log files, then you may have come
across this common pattern -- reading content from some source,
extracting useful data out of it and saving the extracted data in some
other form (or directly using it). And quite often, we need to group
data into parts say for eg. parsing web server access logs and group
incoming requests by their response status
codes. &lt;code&gt;itertools.groupby&lt;/code&gt; makes this very easy. It takes an
iterable and a &lt;code&gt;key&lt;/code&gt; function. The &lt;code&gt;key&lt;/code&gt; function is used to group
items with &lt;em&gt;consecutively&lt;/em&gt; similar key values together. Here is an
example where given a list of integers we separate them into "even"
and "odd" groups.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;groupby&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;groupby_even_odd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;even&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;odd&amp;#39;&lt;/span&gt;
        &lt;span class="n"&gt;gb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;: &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;   &amp;gt;&amp;gt;&amp;gt; groupby_even_odd([1, 3, 4, 5, 6, 8, 9, 11])&lt;/span&gt;
&lt;span class="go"&gt;   odd: 1,3&lt;/span&gt;
&lt;span class="go"&gt;   even: 4&lt;/span&gt;
&lt;span class="go"&gt;   odd: 5&lt;/span&gt;
&lt;span class="go"&gt;   even: 6,8&lt;/span&gt;
&lt;span class="go"&gt;   odd: 9,11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But something is strange, isn't it? The integers are indeed grouped
but there are many "even" and "odd" groups. The reason behind this is,
it only groups &lt;em&gt;consecutive&lt;/em&gt; items together. To get around this, we
can simply provide it a sorted iterable.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;groupby_even_odd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;even&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;odd&amp;#39;&lt;/span&gt;
        &lt;span class="n"&gt;gb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;: &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; groupby_even_odd([1, 3, 4, 5, 6, 8, 9, 11])&lt;/span&gt;
&lt;span class="go"&gt;    even: 4,6,8&lt;/span&gt;
&lt;span class="go"&gt;    odd: 1,3,5,9,11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And now the grouping happens the way we want it. An important thing to
note is that the key function used to sort the list must be same as
the one which is going to be passed to &lt;code&gt;groupby&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Just flatmap that shit!&lt;/h3&gt;
&lt;p&gt;Flatmap is a commonly used pattern in functional programming where
mapping a function to a list results in a list of lists that then
needs to be flattened. For eg. given a list of directories, we want to
get the names of all their first level children as a list.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; import os&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; dirs = [&amp;#39;project1/&amp;#39;, &amp;#39;project2/&amp;#39;, &amp;#39;project3/&amp;#39;]&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; map(os.listdir, dirs)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; [[&amp;#39;settings.py&amp;#39;, &amp;#39;wsgi.py&amp;#39;, &amp;#39;templates&amp;#39;],&lt;/span&gt;
&lt;span class="go"&gt;         [&amp;#39;app.py&amp;#39;, &amp;#39;templates&amp;#39;], &lt;/span&gt;
&lt;span class="go"&gt;         [&amp;#39;index.html, &amp;#39;config.json&amp;#39;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This gives us a list of lists and we still need to flatten it. There
are of course many ways to do this, one way is to use &lt;code&gt;reduce&lt;/code&gt;. But
here is an elegant way using &lt;code&gt;itertools.chain&lt;/code&gt;. &lt;code&gt;chain&lt;/code&gt; takes many
iterables as arguments and chains or appends them at ends.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Edit&lt;/strong&gt;: As correctly pointed out by
&lt;a href="https://news.ycombinator.com/item?id=5767462"&gt;masklinn on hacker news&lt;/a&gt;,
it's better to use &lt;code&gt;imap&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt; and also the alternate
&lt;code&gt;chain&lt;/code&gt; constructor &lt;code&gt;chain.from_iterable&lt;/code&gt; to avoid passing the
lazy object as *args since unpacking with *args will result in eager
evaluation.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let's define a function &lt;code&gt;flatmap&lt;/code&gt; that will map a function to a list
of items and flatten the resulting list of lists.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;chain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;imap&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;flatmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;chain&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_iterable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And now we replace the call to &lt;code&gt;map&lt;/code&gt; with &lt;code&gt;flatmap&lt;/code&gt;,&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; list(flatmap(os.listdir, dirs))&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; [&amp;#39;settings.py&amp;#39;, &amp;#39;wsgi.py&amp;#39;, &amp;#39;templates&amp;#39;, &amp;#39;app.py&amp;#39;, &lt;/span&gt;
&lt;span class="go"&gt;         &amp;#39;templates&amp;#39;, &amp;#39;index.html, &amp;#39;config.json&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Itertools for everything (for fun and learning!)&lt;/h3&gt;
&lt;p&gt;As a final example, let's see how we can compose an elegant solution
entirely using our newly acquired utility belt. The problem is to find
a set of &lt;s&gt;common&lt;/s&gt; (Thanks
&lt;a href="http://naiquevin.github.io/a-look-at-some-of-pythons-useful-itertools.html#comment-908642009"&gt;wcyee&lt;/a&gt;)
factors of a list of integers.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ifilter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;takewhile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;factors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ifilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;takewhile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;        
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; set(flatmap(factors, [9, 15, 16, 23, 76, 101]))&lt;/span&gt;
&lt;span class="go"&gt;    set([1, 2, 3, 4, 5, 38, 8, 9, 76, 15, 16, 19, 23, 101])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That's all for now. If you reached this far, thanks for reading and
hope you found it helpful. Itertools obviously has many more useful
functions and classes. I just skipped them since I failed to come up
with good examples and use cases for them. May be I will do a part II
some time later.&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.python.org/2/library/itertools.html"&gt;Itertools docs&lt;/a&gt;
  (Particularly, check the Recipes section)&lt;/li&gt;
&lt;/ul&gt;</content><category term="python"></category></entry><entry><title>Python generators and being lazy</title><link href="http://naiquevin.github.io/python-generators-and-being-lazy.html" rel="alternate"></link><published>2013-03-01T12:00:00+05:30</published><updated>2013-03-01T12:00:00+05:30</updated><author><name>Vineet Naik</name></author><id>tag:naiquevin.github.io,2013-03-01:/python-generators-and-being-lazy.html</id><summary type="html">&lt;p&gt;A post/tutorial on Python generators with examples&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is going to be a rather long post (call it a tutorial if you
wish), but in case you are a beginner I hope it will help you
understand generators in Python and lazy evaluation and your time will
be well spent. I usually take notes while learning any new stuff and
now I am trying to experiment converting the notes into blog
post/tutorials as I feel it will be a good way for me to revisit and
revise the concepts while being helpful to others at the same time.&lt;/p&gt;
&lt;p&gt;And no, please don't grab a cup of coffee for this one
;-) Instead fire up a Python shell and have your favourite editor
ready because we will be trying out stuff.&lt;/p&gt;
&lt;h4&gt;A simple example&lt;/h4&gt;
&lt;p&gt;The good news is that, to work with Python generators it doesn't
require us to learn much additional syntax. Here is a simple
generator.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gen&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; g = gen()&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; type(g)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;lt;type &amp;#39;generator&amp;#39;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;g&lt;/code&gt; is a generator here. What's happening is that the function &lt;code&gt;gen&lt;/code&gt;
when invoked returns a generator object which is assigned to &lt;code&gt;g&lt;/code&gt;. If
you think I am crazy to say it &lt;em&gt;returns&lt;/em&gt; a generator object, I don't
blame you because it's not immediately clear. After all there is no
&lt;code&gt;return&lt;/code&gt; keyword used. Instead, we see a new keyword &lt;code&gt;yield&lt;/code&gt;. A
function with yield statement will magically return a generator
object.&lt;/p&gt;
&lt;p&gt;The call to the function will not execute any code inside it yet. For
that we need to call the generator object's &lt;code&gt;next&lt;/code&gt; method,&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; g.next()&lt;/span&gt;
&lt;span class="go"&gt;    1&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; print &amp;#39;Hello&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;    Hello&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; g.next()&lt;/span&gt;
&lt;span class="go"&gt;    2&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; g.next()&lt;/span&gt;
&lt;span class="go"&gt;    3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At the time of the first call to the &lt;code&gt;next&lt;/code&gt;, the yield statement will
be executed once and a value will be returned. At the same time, the
control will also be returned back to the calling code. On the next
call to the &lt;code&gt;next&lt;/code&gt; method, the control goes back to the function and
it can resume the execution from where it left with full access to the
local variables again.&lt;/p&gt;
&lt;h4&gt;Iterator protocol and Generator expressions&lt;/h4&gt;
&lt;p&gt;Generators support the
&lt;a href="http://docs.python.org/2/library/stdtypes.html?highlight=iterator#iterator-types"&gt;iterator protocol&lt;/a&gt;
i.e. they implement the &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;__iter__&lt;/code&gt; methods and raise
&lt;code&gt;StopIteration&lt;/code&gt; exception when no more values can be yielded. Hence
we can use a for loop to generate values from a generator instead of
calling the next method manually. &lt;code&gt;for&lt;/code&gt; will implicitly handle
&lt;code&gt;StopIteration&lt;/code&gt; and when that happens, will end the loop.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In fact there also exist list comprehensions equivalent for generators
called generator expressions. The syntax again is ridiculously
similar, the only change being, round brackets &lt;code&gt;()&lt;/code&gt; instead of
square &lt;code&gt;[]&lt;/code&gt;. The difference is that it will give us an iterator (a
generator object) instead of an iterable (a list in memory).&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; squares = [i*i for i in range(1, 11)] # list    &lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; type(squares)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;lt;type &amp;#39;list&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; gen_squares = (i*i for i in range(1, 11)) # generator object&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; type(gen_squares)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;lt;type &amp;#39;generator&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; iter(gen_squares) is gen_squares&lt;/span&gt;
&lt;span class="go"&gt;    True    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Why generators?&lt;/h4&gt;
&lt;p&gt;Now you may ask how does this differ from an ordinary list and what is
the use of all this anyway? The key difference is that the generator
gives out new values on the fly and doesn't keep the elements in
memory. Turns out, our earlier example was not quite apt for
understanding the concept as we used &lt;code&gt;range&lt;/code&gt; to build a list in memory
upfront. As a practical example, let's define a function to give us
incremental values infinitely.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;infinitely_incr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; iinf = infinitely_incr()&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; iinf.next()&lt;/span&gt;
&lt;span class="go"&gt;    1&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; iinf.next()&lt;/span&gt;
&lt;span class="go"&gt;    2&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; iinf.next()&lt;/span&gt;
&lt;span class="go"&gt;    3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can call &lt;code&gt;iinf.next()&lt;/code&gt; as many times as we want to get an
incremented number each time without having a list in memory. This is
pretty cool.&lt;/p&gt;
&lt;p&gt;Let's consider another example. What if we have huge data in some file
and need to process each of it's lines by calling one or many
functions on them,&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gen1&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hugedata.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;    
    &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gen1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;    
    &lt;span class="n"&gt;g2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In python, a file object can be iterated over to obtain one line at a
time. In the above example, since the &lt;code&gt;process&lt;/code&gt; function is called
inside a generator expression, it will not be executed until the for
loop starts consuming the generator. That is when the &lt;code&gt;process&lt;/code&gt;
function will execute for each value. Don't worry if all this sounds
confusing at the moment since the next example will clarify
things. But if you think about it, the cost of loading all data from
the huge file into memory is avoided. On the other hand, it also means
that the file cannot be closed until all the lines are processed.&lt;/p&gt;
&lt;p&gt;Also, not keeping the elements in memory implies that a generator
object can be looped through or consumed only once. So it is obviously
not a good choice if the sequence of items need to be reused in which
case a normal list would be suitable.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; g = gen()&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; squares = (i*i for i in g)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; list(squares)&lt;/span&gt;
&lt;span class="go"&gt;    [1, 4, 9, 16, 25]&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; cubes = (i*i*i for i in g)&lt;/span&gt;
&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; list(cubes)&lt;/span&gt;
&lt;span class="go"&gt;    []&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But if you have a series of functions, that need to be executed one
after another on each line of a file, then the laziness of generator
expressions can be tremendously useful.&lt;/p&gt;
&lt;h4&gt;Understanding the 'lazy' using a &lt;s&gt;concrete&lt;/s&gt; contrived example&lt;/h4&gt;
&lt;p&gt;So, what does being lazy mean after all? Imagine our hugedata.txt
contains some 100000 lines with 1 random number on each line and we
want to find out the digit sum of the square of each number and print
out the results in the shell. Here is an example that uses list
comprehensions and hence will build and keep lists in memory.&lt;/p&gt;
&lt;p&gt;For the sake of an example and to make sense out of the results, let's
assume that our hugedata.txt is actually a tiny file of just 5 lines
containing the first 5 positive integers :-)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Square of &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt; -&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;        
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;digit_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Digit Sum of &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt; -&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;squares&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;dsums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;digit_sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;squares&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dsums&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Running the above snippet of code will produce an output as follows,&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    Square of 1 -&amp;gt; Square of 2 -&amp;gt; Square of 3 -&amp;gt; Square of 4 -&amp;gt; Square
    of 5 -&amp;gt; Digit Sum of 1 -&amp;gt; Digit Sum of 4 -&amp;gt; Digit Sum of 9 -&amp;gt; Digit
    Sum of 16 -&amp;gt; Digit Sum of 25 -&amp;gt; 
    1
    4
    9
    7
    7
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First all squares will be calculated, then their digit sums and then
the results will be printed one by one.&lt;/p&gt;
&lt;p&gt;Now with generator expressions just see what we get,&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    numbers = gen1()
    squares = (square(n) for n in numbers)
    dsums = (digit_sum(n) for n in squares)
    for n in dsums:
        print n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Output:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    Square of 1 -&amp;gt;  Digit Sum of 1 -&amp;gt;  1
    Square of 2 -&amp;gt;  Digit Sum of 4 -&amp;gt;  4
    Square of 3 -&amp;gt;  Digit Sum of 9 -&amp;gt;  9
    Square of 4 -&amp;gt;  Digit Sum of 16 -&amp;gt;  7
    Square of 5 -&amp;gt;  Digit Sum of 25 -&amp;gt;  7
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Every item is processed by each function sequencially similar to how
it would have been if there was just one &lt;code&gt;for&lt;/code&gt; loop and all
functions were called progressively on the derived values of the item
in each iteration. This is quite awesome if you can imagine numbers
flowing through functions similar to signals flowing through various
stages of a signal processor.&lt;/p&gt;
&lt;p&gt;It's called lazy because the numbers are getting consumed late, at the
time of iteration. The implicit call to &lt;code&gt;next&lt;/code&gt; by the &lt;code&gt;for&lt;/code&gt; loop
asks for &lt;code&gt;digit_sum&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;dsums&lt;/code&gt; which asks for the &lt;code&gt;square&lt;/code&gt;
of &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;squares&lt;/code&gt; which asks for &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;numbers&lt;/code&gt;. This
continues till &lt;code&gt;numbers&lt;/code&gt; can yield a value. Nothing is evaluated
unless it is asked for.&lt;/p&gt;
&lt;h4&gt;Common traps and things to watch out for&lt;/h4&gt;
&lt;p&gt;Just like in case of many other cool language features, there are a
few gotchas and things that we need to watch out for when using
generators as it's very easy to screw things up.&lt;/p&gt;
&lt;p&gt;Rule #0 is - Use generators wisely. Don't use a generator expression
only because the syntax is slightly different from list
comprehensions.&lt;/p&gt;
&lt;p&gt;Also, as we saw earlier, if the sequence needs to be reused then
simply use a list. Keeping stuff in memory is not bad after all (we do
that all the time while caching values, don't we?)&lt;/p&gt;
&lt;p&gt;Another important thing to watch out for is the scope of the variables
that are going to be used by functions when they execute in a lazy
manner. This needs a bit more explanation so here is an example.&lt;/p&gt;
&lt;p&gt;Suppose we have a generator that yeilds alphabets and we need to add
two suffixes to each alphabet for eg. we have alphabet &lt;code&gt;a&lt;/code&gt;. First
it's suffixed with &lt;code&gt;x&lt;/code&gt; which makes it &lt;code&gt;ax&lt;/code&gt; and then with &lt;code&gt;y&lt;/code&gt; which
makes it &lt;code&gt;axy&lt;/code&gt;. We need to do this with multiple alphabets and we
choose to use a generator object to yield each alphabet.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add_suffix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;suffix&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;suffix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gen&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;            
    &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;suffixes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;suffixes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_suffix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What do you think will be output of the above program? If your mind
tells you &lt;code&gt;['axy', 'bxy', 'cxy', 'dxy']&lt;/code&gt; then it's wrong. Just run it
and see it for yourself that the output we get is
&lt;code&gt;['ayy', 'byy', 'cyy', 'dyy']&lt;/code&gt;. What's happening here?&lt;/p&gt;
&lt;p&gt;A generator can remember the local variables when it gets back the
control on the call of &lt;code&gt;next&lt;/code&gt; method. The local scope here is actually that of
the &lt;code&gt;for&lt;/code&gt; loop. By the time the generator is consumed upon call to
&lt;code&gt;list(ns)&lt;/code&gt;, the value of &lt;code&gt;s&lt;/code&gt; in local scope is &lt;code&gt;y&lt;/code&gt;. The value &lt;code&gt;x&lt;/code&gt; in
the previous iteration of suffixes is simply lost.&lt;/p&gt;
&lt;p&gt;To fix this, we just define another function wrapping over the call to
the &lt;code&gt;add_suffix&lt;/code&gt; function that will return a generator object&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gen1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sfx&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;add_suffix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sfx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;            
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;suffixes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gen1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;    &amp;gt;&amp;gt;&amp;gt; list(ns)&lt;/span&gt;
&lt;span class="go"&gt;    [&amp;#39;axy&amp;#39;, &amp;#39;bxy&amp;#39;, &amp;#39;cxy&amp;#39;, &amp;#39;dxy&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;This is by no means all about generators&lt;/h4&gt;
&lt;p&gt;I know there is lot more to generators than what this post covers. You
should only consider this as a starting point for digging deeper into
them. It would also be worth mentioning about the use of generator as
co-routines where it can accept values from the calling code besides
yeilding to it. Co-routines are pretty advanced and mind bending to
understand and I am still trying to explore this topic. I got
interested in it after attending a talk on 'Data processing pipelines'
by Ami Tavory at SciPy India 2012 where he also showed
&lt;a href="http://code.google.com/p/dagpype/"&gt;Dagpype&lt;/a&gt; - A framework written by
him for data processing and preparation.&lt;/p&gt;
&lt;h4&gt;References:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.dabeaz.com/generators/"&gt;Generator Tricks for system programmers&lt;/a&gt; by David Beazley 
  (particularly a must read)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/library/l-pycon/index.html"&gt;Iterators and simple generators&lt;/a&gt; by David Mertz&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Core-Python-Programming-Wesley-Chun/dp/0132269937"&gt;Core Python Programming Book&lt;/a&gt; by Wesley Chun&lt;/li&gt;
&lt;li&gt;I would also like to recommend this recently published
  &lt;a href="http://excess.org/article/2013/02/itergen1/"&gt;article&lt;/a&gt; by Ian Ward.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;If you are curious about co-routines, also see,&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://dabeaz.com/coroutines/"&gt;A Curious Course on Coroutines and Concurrency&lt;/a&gt;
  (again by David Beazley) &lt;/li&gt;
&lt;li&gt;&lt;a href="http://excess.org/article/2013/02/itergen2/"&gt;Part II&lt;/a&gt; of the above
  article by Ian Ward&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;People who helped improve the post by pointing out errors and bugs. Thanks!&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://twitter.com/jimymodi"&gt;Jimit Modi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sanjay Bhangar&lt;/li&gt;
&lt;/ul&gt;</content><category term="python"></category><category term="generators"></category></entry></feed>